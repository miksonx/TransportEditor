\chapter{Transport domain}

\section{Automated planning}

Planning is usually defined as the reasoning side of acting -- an abstract deliberation
process that chooses and organizes actions by anticipating their outcomes. \cite[Section~1.1]{Ghallab2004}
It seems only natural that we want to have computers to do this strenuous activity for us.
Automated planning is an attempt at just that -- it is an area of Artificial Intelligence (AI) that
studies the planning process computationally. \cite[Section~1.1]{Ghallab2004}

\TODO{Define domain and problem, planner?}

Unfortunately, the specific situations in which we want to use automated planning are very diverse --
from devising a sequence of actions to shut down a nuclear power plant to planning the robotic arm
movements in an assembly line or devising the complex motor activations for space aircraft positioning.
Due to this, people are often interested in domain-independent planning, where the planner gets information
about both the domain and the specific problem and attempts to devise a plan using only the provided knowledge
and its previously built-in processes. \cite[Section~1.3]{Ghallab2004}

On the other hand, domain-specific planning, where domain knowledge has been built into the planner,
has obvious advantages when solving problems in that domain -- all the while being useless on problems of other
domains. \cite[Section~1.3]{Ghallab2004}

\subsection{Planning model}

As a basis for the later-defined representation of planning, we first define
a conceptual model similar to the restricted model in \cite[Section~1.4, Section~1.5]{Ghallab2004}.

\begin{defn}[State-transition system]\label{defn:state-transition-sys}
A (restricted) state-transition system is a 3-tuple $\Sigma = (S, A, \gamma)$, where:
\begin{itemize}
\item $S = \{s_1, s_2, \ldots\}$ is a finite and fully observable set of states,
\item $A = \{\noop, a_1, a_2, \ldots\}$ is a finite set of actions;
\item $\gamma: S \times A \to S \cup \{\emptyset\}$ is a state-transition function,
where $\forall s \in S : \gamma(s, \noop) = s$,
and $\forall s \in S\,\exists a \in A : \gamma(s, a) \neq \emptyset$; and
\item $\Sigma$ is static and offline,
it only changes when an action is applied to it and does not change while planning.
\end{itemize}
In the basic version, all actions have no duration.
\end{defn}

\noindent \TODO{define goals and mention that planning domains correspond to state-transition systems}

\begin{defn}[Planning problem]\label{defn:planning-problem}\cite[Part~I]{Ghallab2004}
A planning problem is a 5-tuple $\mathcal{P} = (S, A, \gamma, s_0, g)$, where:
\begin{itemize}
\item $(S, A, \gamma)$ is a state-transition system;
\item $s_0 \in S$ is an initial state; and
\item $g \subseteq S$ is a set of goal states.
\end{itemize}
\end{defn}

\noindent For notation purposes, we define $[k] := \{1, 2, \ldots, k\}$ for all $k \in \N$

\begin{defn}[Plan]\label{defn:plan}\cite[Section~1.5]{Ghallab2004}
For a planning problem $\mathcal{P} = (S, A, \gamma, s_0, g)$,
a plan is a finite ($k \in \N$) sequence of actions $(a_1, a_2, \ldots, a_k)$ where
$\forall i \in [k] : a_i \in A$ such that
$\forall i \in [k] : \gamma(s_{i-1}, a_i) = s_i$ and $s_k \in g$.
\end{defn}

\noindent A basic planning model consists of three components:

\begin{itemize}
\item A \textit{state-transition system} $\Sigma$ that evolves by its state-transition function using the actions
it receives.
\item A \textit{controller} -- given an input state $s \in S$ provides an action $a \in A$ as output according
a plan.
\item A \textit{planner} -- uses a description of $\Sigma$ to synthesize a plan for the controller
to execute in order to achieve the objective.
\end{itemize}

\TODO{image of the system}

\subsection{Classical planning}

Although the previously defined restricted state-transition system is a simplification of real-world
problems, it is a useful one. 
This simplification has historically been studied as classical planning.
There are several theoretical domain-independent representations
of planning problems in classical planning: \cite[Chapter 2]{Ghallab2004}

\begin{itemize}

\item \textbf{Set-theoretic representation}: both the planning domain and problem are represented with the notion
of proposition symbols $L = \{p_1, p_2, \ldots\}$. Each state is defined as a subset of $L$, each action
is a 3-tuple of subsets of $L$: $a = (\precond(a), \effects^-(a), \effects^+(a))$ -- the preconditions and
the negative and positive effects of $a \in A$. $S$ is closed under the application of effects
for each $a \in A$. The state-transition function is $\gamma(s, a) = (s - \effects^-(a)) \,\cup\,
\effects^+(a)$ if $a$ is applicable to $s$,
otherwise $\gamma(s, a)$ is undefined. Goal states are defined inductively using the goal propositions
$g \subseteq L$ as $S_g = \{s \in S \,|\, g \subseteq L\}$.
 
\item \textbf{Classical representation}:
generalizes the set-theoretic representation using first-order logic, without functions.
States are sets of ground atoms of a first-order language.
Actions are ground instances of \textit{planning operators}
-- triples $o = (\name(o), \precond(o), \effects(o))$,
where $\name(o)$ is a syntactic expression of the given operator;
$\precond(o)$ and $\effects(o)$ are sets of literals (atoms and their negations),
similar to the set-theoretic case.
The definition of the state-transition function is the same.
Goal states are defined as the set of states that satisfy $g$, the goal, where $g$ is any set
of ground literals.

\TODO{Relation of $\Sigma$ to $\mathcal{P}$, Soundness, extensions?}

\item \textbf{State-variable representation}: substitutes the use of relations of the two previous representations for functions, using the concept of state variables. State-variable functions are \TODO{def}.

\end{itemize}

Both the set-theoretic and the classical representations follow the \textit{Closed world assumption} -- that any atom/predicate not present in the state does not hold in the state.

\subsection{Neoclassical planning}



\subsection{Temporal planning}



\section{Transport domain definition}

\TODO{Focus on a few domain variants, just show the others}

\subsection{Key insights}

\TODO{degenerate cases, etc.}

\subsection{Sequential Transport's classical representation}

\begin{code}
drive(v, l1, l2)
  ;; vehicle v moves from location l1 to an adjacent location l2
  precond: at(v, l1), road(l1, l2)
  effects: not at(v, l1), at(v, l2)

pick-up(v, l, p, s1, s2)
  ;; vehicle v picks up package p at location l,
  ;; decreasing its capacity from s2 to s1
  precond: at(v, l), at(p, l), capacity-predecessor(s1, s2),
           capacity(v, s2)
  effects: not at(p, l), in(p, v), capacity(v, s1),
           not capacity(v, s2)
  
drop(v, l, p, s1, s2)
  ;; vehicle v drops package p at location l,
  ;; increasing its capacity from s1 to s2
  precond: at(v, l), in(p, v), capacity-predecessor(s1, s2),
  		   capacity(v, s1)
  effects: not in(p, v), at(p, l), capacity(v, s2),
           not capacity(v, s1)
\end{code}

\TODO{The fuel variant adds another operator
refuel along with a change to the operator drive}

\subsection{Sequential Transport's state-variable representation}

\begin{code}
drive(v, l1, l2)
  ;; vehicle v moves from location l1 to an adjacent location l2
  precond: at(v) = l1, road(l1, l2)
  effects: at(v) <- l2

pick-up(v, l, p, s1, s2)
  ;; vehicle v picks up package p at location l,
  ;; decreasing its capacity from s2 to s1
  precond: at(v) = l, at(p) = l, capacity-predecessor(s1, s2),
           capacity(v) = s2
  effects: at(p) <- nil, in(p) <- v, capacity(v) <- s1
  
drop(v, l, p, s1, s2)
  ;; vehicle v drops package p at location l,
  ;; increasing its capacity from s1 to s2
  precond: at(v) = l, in(p) = v, capacity-predecessor(s1, s2),
  		   capacity(v) = s1
  effects: in(p) <- nil, at(p) <- l, capacity(v) <- s2
\end{code}

\subsection{Sequential Transport's graphplan? representation}

\subsection{PDDL}

Originally proposed by McDermott et al. in 1998 for the 1$^{\mathrm{st}}$ International Planning
Competition\footnote{http://ipc98.icaps-conference.org/} (IPC),
the Planning Domain Definition Language\cite{McDermott1998} (PDDL) has become
a de facto standard language for planning problems, continually evolving to the needs of the
research community and the needs of the IPC itself in the future years.

It was inspired by the language used to describe STRIPS,
the Stanford Research Institute Problem Solver\cite{Fikes1971},
a planner proposed in the 1970's. Hence one of the more basic variants of PDDL is sometimes
referred to as STRIPS.

For reference, we show the PDDL representation of the sequential variant of
the Transport domain.

\begin{code}
(define (domain transport)
  (:requirements :typing :action-costs)
  (:types
        location target locatable - object
        vehicle package - locatable
        capacity-number - object)
  (:predicates 
     (road ?l1 ?l2 - location)
     (at ?x - locatable ?v - location)
     (in ?x - package ?v - vehicle)
     (capacity ?v - vehicle ?s1 - capacity-number)
     (capacity-predecessor ?s1 ?s2 - capacity-number))
  (:functions
     (road-length ?l1 ?l2 - location) - number
     (total-cost) - number)
     
  (:action drive
    :parameters (?v - vehicle ?l1 ?l2 - location)
    :precondition (and (at ?v ?l1) (road ?l1 ?l2))
    :effect (and (not (at ?v ?l1)) (at ?v ?l2)
        (increase (total-cost) (road-length ?l1 ?l2))))
        
 (:action pick-up
    :parameters (?v - vehicle ?l - location ?p - package
                 ?s1 ?s2 - capacity-number)
    :precondition (and (at ?v ?l) (at ?p ?l)
        (capacity-predecessor ?s1 ?s2) (capacity ?v ?s2))
    :effect (and (not (at ?p ?l)) (in ?p ?v) (capacity ?v ?s1)
        (not (capacity ?v ?s2)) (increase (total-cost) 1)))
        
  (:action drop
    :parameters (?v - vehicle ?l - location ?p - package
                 ?s1 ?s2 - capacity-number)
    :precondition (and (at ?v ?l) (in ?p ?v)
        (capacity-predecessor ?s1 ?s2) (capacity ?v ?s1))
    :effect (and (not (in ?p ?v)) (at ?p ?l) (capacity ?v ?s2)
        (not (capacity ?v ?s1)) (increase (total-cost) 1))))
\end{code}


\section{The Vehicle Routing Problem}

\TODO{mention Dantzig} \cite{Dantzig1959}

\subsection{Constraint Satisfaction Problems}

\subsection{Problem formulation}

\subsection{Comparison to the Transport domain formulation}

\subsection{Formulating the sequential Transport domain as a VRP problem}

\TODO{Ghallab 8.3}
