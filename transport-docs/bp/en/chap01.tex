\chapter{Analysis of transportation planning problems}

In this chapter, we formalize the concept of planning to help us with formally introducing the studied transportation problems. We will also briefly discuss specifics of the Transport domain and mention similar studied problems.

















\section{Automated planning}

As previously stated, \textit{planning} is usually defined as the reasoning side of acting -- an abstract deliberation
process that chooses and organizes actions by anticipating their outcomes. \citep[Section~1.1]{Ghallab2004}
It seems only natural that we want to have computers do this strenuous activity for us.
Automated planning is an attempt at just that -- it is an area of Artificial Intelligence (AI) that
studies the planning process computationally. \citep[Section~1.1]{Ghallab2004}

Unfortunately, the specific situations in which we want to use automated planning are very diverse --
from devising a sequence of actions to shut down a nuclear power plant,
planning the movements of a robotic arm
on an assembly line, or devising the complex pattern of motor activations
for space aircraft positioning.
Due to this, researchers are often interested in domain-independent planning,
where the planner gets information
about both the domain and the specific problem at runtime and attempts to devise a plan using only the provided knowledge
and the planner's previously built-in processes. \citep[Section~1.3]{Ghallab2004}

On the other hand, domain-specific planning, where domain knowledge has been built into the planner,
has obvious advantages when solving problems in that domain -- all the while being useless on problems of other
domains. \citep[Section~1.3]{Ghallab2004}

\subsection{Planning model}

As a basis for the later-defined representation of planning, we first define
a conceptual model similar to the restricted model in \citep[Section~1.4, Section~1.5]{Ghallab2004}.

\begin{defn}[State-transition system]\label{defn:state-transition-sys}
A (restricted) state-transition system is a 3-tuple $\Sigma = (S, A, \gamma)$, where:
\begin{itemize}
\item $S = \{s_1, s_2, \ldots\}$ is a finite and fully observable set of states;
\item $A = \{\noop, a_1, a_2, \ldots\}$ is a finite set of actions;
\item $\gamma: S \times A \to S \cup \{\emptyset\}$ is a state-transition function,
where $\forall s \in S : \gamma(s, \noop) = s$,
and $\forall s \in S\,\exists a \in A : \gamma(s, a) \neq \emptyset$; and
\item $\Sigma$ is static and offline,
it only changes when an action is applied to it and does not change while planning.
\end{itemize}
In the basic version, all actions have no duration.
\end{defn}

For a state $s \in S$, the actions $A_s = \{a \in A | \gamma(s, a) \neq \emptyset\}$ are called \textit{applicable}
to the given state $s$. The $\noop$ action is applicable to all states.

The state-transition function $\gamma$ and the set of actions $A$ together loosely correspond to what we will call a \textit{planning domain}.
Planning domains define an abstract representation of actions we work with
and how they are related,
but they do not state anything about specific states or actions.

Given a state-transition system $\Sigma$, planning aims to find a
sequence of actions to apply to the beginning state in order to achieve some objective.
The objective can be defined in various ways -- we might want the planner
to devise a plan that
does not enter specific states, or contrary to that, visits each of a set of states,
or one that just ends at a chosen state.
We will use the last option for formalizing the notion of a \textit{planning problem}.

\begin{defn}[Planning problem]\label{defn:planning-problem}\citep[Part~I]{Ghallab2004}
A planning problem is a 5-tuple $\mathcal{P} = (S, A, \gamma, s_0, g)$, where:
\begin{itemize}
\item $(S, A, \gamma)$ is a state-transition system;
\item $s_0 \in S$ is an initial state; and
\item $g \subseteq S$ is a set of goal states.
\end{itemize}
\end{defn}

Now that we have defined a \textit{planning problem} we can specify what we mean
by the planner generating a \textit{sequence of actions} to achieve a goal -- we will
call this sequence a \textit{plan}.
For notation purposes, we define $[k] := \{1, 2, \ldots, k\}$ for all $k \in \N$.

\begin{defn}[Plan]\label{defn:plan}\citep[Section~1.5]{Ghallab2004}
For a planning problem $\mathcal{P} = (S, A, \gamma, s_0, g)$,
a plan is a finite sequence of actions $(a_1, a_2, \ldots, a_k),\, k \in \N$ where
$\forall i \in [k] : a_i \in A$ and
$\forall i \in [k] : \gamma(s_{i-1}, a_i) = s_i \in S$, while $s_k \in g$.
\end{defn}

A basic \textit{planning model}, i.e. the abstraction of a whole real-life scenario
we want to plan for, consists of three components (Figure~\ref{fig:planning-model}):

\begin{itemize}
\item A \textit{state-transition system} $\Sigma$ that evolves by its state-transition function using the actions
it receives;
\item A \textit{controller} -- given an input state $s \in S$ provides an action $a \in A$ as output according
to a plan; and
\item A \textit{planner} -- uses a description of the state-transition system $\Sigma$ to synthesize a plan for the controller
to execute in order to reach a goal state from the initial state.
\end{itemize}

\begin{figure}[tb]
\begin{center}
\includegraphics[width=0.7\textwidth]{../imga/planning_model}
\end{center}
\caption[A typical planning model for offline planning.]{A typical planning model for offline planning -- a state-transition system $\Sigma$, a controller executing a plan, and a planner devising the plan based on an initial state and goals. Adapted from \citep[Figure~1.3]{Ghallab2004}.}
\label{fig:planning-model}
\end{figure}

\subsection{Classical planning}\label{classical-planning}

Although the previously defined restricted state-transition system is a simplification of real-world
domains, it is a useful one. 
This simplification has historically been studied as classical planning.

A different branch of automated planning, \textit{neoclassical planning},
uses largely the same theoretical foundations as classical 
planning. What is different is the approach to planning using those foundations
-- instead of search space nodes being a sequence of actions or a partially ordered
set of actions, we view them as a set of several partial plans
\citep[Part~II]{Ghallab2004}.
One of the most famous results in neoclassical planning is the GraphPlan algorithm
published by \citet{Blum1997}. It is out of the scope of this text to describe it in detail
-- see \citet[Section~6.3]{Ghallab2004}.
GraphPlan makes heavy use of a data structure called a \textit{planning graph},
which caused a breakthrough in the field of (domain-independent) planning
-- bigger problems could now be practically solved.

We will now describe several theoretical domain-independent representations
of planning problems used in classical planning \citep[Chapter~2]{Ghallab2004},
so that we can formulate our domain using them.

\subsubsection{Set-theoretic representation}

Leveraging propositional logic, both the planning domain and problem
are represented with the notion
of proposition symbols $L = \{p_1, p_2, \ldots\}$.
Each state is defined as a subset of propositions of $L$ -- those propositions
which hold in the given state. $S$ is closed under the application of each
action $a \in A$.

An action $a$
is a triple of sets of propositions of $L$.
We denote the sets $a = (\precond(a), \effects^-(a), \effects^+(a))$, where:
\begin{itemize}
\item $\precond(a)$ are the \textit{preconditions} of an action: the set of
propositions that must hold in the current state for the action to be applicable to it;
\item $\effects^-(a)$ are the \textit{negative effects} of an action:
the set of propositions
that will no longer hold in the state once the action is applied; and
\item similarly, $\effects^+(a)$ are the \textit{positive effects} of an action:
the set of propositions that will be true in the state once the action is applied.
\end{itemize}

The state-transition function is $\gamma(s, a) = (s - \effects^-(a)) \,\cup\,
\effects^+(a)$ if $a$ is applicable to $s$,
otherwise $\gamma(s, a)$ is undefined. Goal states $S_g$ are defined as
$S_g = \{s \in S \,|\, g \subseteq s\}$, where
$g \subseteq L$ is any chosen set of propositions. The propositions $g$ are called
\textit{goal propositions}.

\subsubsection{Classical representation}

The classical representation generalizes the set-theoretic representation using first-order logic,
without functions.
States are sets of ground atoms of a first-order language.
Actions are ground instances of \textit{planning operators},
triples $o = (\name(o), \precond(o), \effects(o))$:

\begin{itemize}
\item $\name(o)$ is a syntactic expression of the given operator;
\item $\precond(o)$ and $\effects(o)$ are sets of literals
(atoms and their negations), similar in use to their equivalents
in the set-theoretic case.
\end{itemize}

The definition of the state-transition function also stays the same.
Goal states are defined as the set of states that satisfy $g$,
the \textit{goal}, where $g$ is any set of ground literals.

Both the set-theoretic and the classical representations follow the \textit{Closed world assumption} -- that any atom/predicate not present in the state does not hold in that state.

\subsubsection{State-variable representation}

The state-variable representation substitutes the use of relations of the previous
representation for functions,
using the concept of state variables. State variables are functions
that take the state as an input and serve as characteristic attributes, defining the state. We usually use a more practical way of defining these functions -- we assume
the current state as an input without denoting it, and instead add different inputs.

For example, a useful set of state-variable functions for a domain that contains a road
network and vehicles might be: $$\mathrm{location}_{v}: S \to \mathrm{locations},$$
where $v \in \mathrm{vehicles}$.
Instead, we could define a single function:
$$\mathrm{location'}: \mathrm{vehicles} \times S \to \mathrm{locations},$$
and afterwards 
$$\mathrm{location''}: \mathrm{vehicles} \to \mathrm{locations},$$
using $\mathrm{location''}(v) = \mathrm{location'}(v, state_{cur})$, where $state_{cur}$ is the current state.

Planning operators are defined similarly to the classical representation, but
$\precond(o)$ is now a set of expressions on state variables and relations.
Also, $\effects(o)$ is defined as a set of assignments of values to state variables.
The state-transition function is defined analogously: an action $a$ (ground instance
of operator $o$)
is applicable to a state $s$ if the $\precond(o)$ condition is true given the values
of state variables in state $s$. The resulting state is created by changing the state variables
according to the assignments in $\effects(o)$ and the corresponding values of state
variables in state $s$.
The goal is defined as a set of ground state variables and their corresponding values
\citep[Section~2.5.2]{Ghallab2004}.


\subsubsection{Extensions of representations}

We will later extend these representations using types.
To see how types fit into our previously defined representations, we can
define a \textit{type} as a unary predicate, which has the value true
if and only if the predicate's argument is of the given type.
We can then add these predicates as preconditions of actions.
Adding types will make the domain and problem formulations
easier to read and gives additional information
to planners, making them more efficient \citep[Section 2.4.1]{Ghallab2004}.

\subsubsection{State-space planning and Plan-space planning}

A different way of viewing the state-transition system $\Sigma = (S, A, \gamma)$ in a
planning problem $\mathcal{P} = (S, A, \gamma, s_0, g)$ (Definition~\ref{defn:state-transition-sys}~and~\ref{defn:planning-problem}), is that of a labeled, directed graph $G(S, E, w)$, where:
\begin{itemize}
\item $E = \{(u, v) \in S^2 \;|\; \exists a \in A : \; \gamma(u, a) = v\}$;
\item $w: E \to A$; and
\item $\forall (u, v) = e \in E : w(e) = \{a \in A \;|\; \gamma(u, a) = v\}$. 
\end{itemize}
From the definition above, we see that applicable actions correspond to state transitions. While planning, the plan represented by the current position in
the state space is the sequence of transitions from the start
state $s_0$ to the current state \citep[Section~4.1]{Ghallab2004}.
\textit{State-space planning} is a term used for planning techniques
that use the state space for searching for a plan.

An alternative for using the state space is offered by \textit{plan-space planning}.
The state space is substituted for the \textit{plan space}.
Nodes in this space represent \textit{partially specified plans},
edges are \textit{plan refinement operations} \citep[Section~5.1]{Ghallab2004}.
We will not use plan-space planning in this work, as according to
\citet[Section~5.6]{Ghallab2004} it is unfit for
incorporating domain-specific knowledge.

\subsubsection{Temporal planning}

\TODO{temporal planning \citep[Chapter~14]{Ghallab2004}, possibly \citep[Chapter~15]{Ghallab2004}, small reference to the temporal Transport domain variant}.

\subsection{PDDL}\label{pddl}

Originally proposed by \citet{McDermott1998} for the 1$^{\mathrm{st}}$ International Planning
Competition\footnote{\url{http://ipc98.icaps-conference.org/}},
the Planning Domain Definition Language (PDDL) has become
a de facto standard language for modelling planning domains and problems,
continually evolving to the needs of the  
research community and the needs of the IPC itself in the future years.
We will also use it as input for our planners.

PDDL was inspired by the language used to describe STRIPS \citep{Fikes1971}
and the numerous languages that sparked from it.
It has a Lisp-like\footnote{\url{https://en.wikipedia.org/wiki/Lisp_(programming_language)}}
declarative syntax and is very extensible.
Not many planners support PDDL in its entirety -- they usually support 
several ``feature subsets'', called \textit{requirements}.
Over time, PDDL has evolved from the originally proposed version 1.2
to the now standard version 3.1. Several extensions and successors were proposed,
like Multi-Agent PDDL\comment{\footnote{\url{http://agents.fel.cvut.cz/codmap/}}}
(MA-PDDL) and
Probabilistic PDDL\comment{\footnote{\url{http://www.tempastic.org/papers/CMU-CS-04-167.pdf}}}
(PPDDL).

PDDL does not handle plan representation. For a specific planning domain and problem in PDDL,
the we represent the plan in a format that is a field-wide consensus -- we will refer to is
as the \textit{VAL-like} format. VAL \citep{Howey2003} is a plan validator created for the IPC.
It takes as input (among several options) three filenames: filename of a planning domain and
problem in PDDL, and a filename for a plan in the mentioned format.
As described in and around \citet[Figure~2]{Howey2003}, the approximate format
consists of multiple lines in the following format:
\begin{center}
\verb+(action_name action_object_literals*)+
\end{center}

For temporal domains, the format adds a start time and duration for each line, like so:
\begin{center}
\verb+start_time: (action_name action_object_literals*) [duration]+
\end{center}

Note that all text between a semicolon \verb+;+ and an end-of-line character sequence \verb+\r+, \verb+\n+, or \verb+\r\n+ is regarded as a comment and ignored by all parsers.

\subsection{Planning in practice}

In practice, many of the assumptions we made will get violated and many additional requirements will arise,
due to various business or social requirements.
These assumptions allow us, however, to work
on problems that are more general and can therefore be applied to multiple scenarios.
Businesses can often add minor tweaks on top of the obtained results so that
their needs are satisfied. 
For example, online planning can often be foregone for some form of \textit{windowed} planning,
where we plan a certain time window offline and move on to the next window,
repeating the process regularly.

Planners, in practice, are computer programs that are fed two files as input
-- the domain file and the problem file. After that, they proceed with their internal calculations
and upon finishing return a plan (or not). 
We can then evaluate the plan, see if it meets our criteria and, potentially,
execute it in the real world.

What we are missing from a bare plan is the allocation of specific resources.
\textit{Scheduling} addresses the problem of how to perform a given set of actions (a plan)
using a limited number of resources in a limited amount of time, and
that is crucial to practical usage of any plan \citep[Chapter~15]{Ghallab2004}.

In this text, we will only study the abstracted and simplified first part of this whole process
-- finding the ``best'' actions that lead to a specified goal.


















\section{Description of Transport domain variants}

Transport is a planning domain designed for
the International Planning
Competition\footnote{\url{http://www.icaps-conference.org/index.php/Main/Competitions}}
(IPC), which is part of the International Conference on Automated Planning and
Scheduling\footnote{\url{http://www.icaps-conference.org/index.php/Main/HomePage}} (ICAPS).
Originally, Transport appeared at 
IPC-6\footnote{\url{http://icaps-conference.org/ipc2008/deterministic/Domains.html}} which took place in 2008.
Since then, it has been used in two IPCs,
specifically IPC-7\footnote{\url{http://www.plg.inf.uc3m.es/ipc2011-deterministic/}} in 2011
and IPC-8\footnote{\url{https://helios.hud.ac.uk/scommv/IPC-14/}} in 2014.

There are a few basic formulations of the Transport domain family (i.e.~``similar'' Transport domain variants) which we will describe now.

\subsection{Common traits of Transport domains}

Transport is a logistics domain -- vehicles drive around on a (generally asymmetric) positively-weighted oriented graph, picking up and dropping packages along the way.
All vehicles have limited capacities (the sum of package sizes they can carry).
Picking up or dropping a package costs 1 unit. The cost of driving along a road is equal to the edge weight
(in other words, the road length).
The general goal is to minimize the \textit{total cost}
while delivering all packages to their destination, where
the total cost of a plan is defined as the sum of the costs of all actions in
the plan.

A few Transport problems also request that the trucks be positioned at certain
locations in the graph
after finishing their deliveries.

\subsection{Transport STRIPS}\label{transport-strips}

STRIPS, the Stanford Research Institute Problem Solver,
was a planner proposed in the 1970's by \citet{Fikes1971}.
The influence of STRIPS was, however, not only due to the planner,
but the language used to describe its inputs -- the planning operators and goals.
That is why we sometimes refer to classical planning (Section~\ref{classical-planning})
as STRIPS planning. For the purposes of this text, we will use these terms interchangeably.

In the STRIPS variant of the Transport domain,
all packages have a size of 1 and vehicles of a bounded capacity can drive around indefinitely
(there is no notion of fuel or anything similar). The only reason for them not to, is that
driving incures a cost of its own, usually much larger than pickin up or dropping off packages.
This being a classical STRIPS domain,
it does not assume time in any sense,
so actions have no duration and are applied one after the other, sequentially.

This formulation contains three basic planning operators:

\begin{itemize}
\item \verb+drive+, where a vehicle drives to an adjacent location
along a road that is connected to its current location;
\item \verb+pick-up+, where a vehicle that is stationary at a location picks up a co-located package; and
\item \verb+drop+, where a stationary vehicle drops a package off at its location.
\end{itemize}

In all the datasets, this domain variant is denoted as \textit{Transport sequential}
or \textit{transport-strips} and we will alternate between these terms in this text.

\subsection{Transport Numeric}\label{transport-numeric}

The numeric variant adds the concept of fuel on top of the STRIPS variant.
All roads have an additional cost, called \verb+fuel-demand+, which is
subtracted from a vehicle's \verb+fuel-left+ value if it chooses to drive along that road.
Additionally, all vehicles have a maximum fuel capacity \verb+fuel-max+,
which they regain upon being the target of a \verb+refuel+ action. This action can only
be executed at a location that is marked as having a petrol station. Petrol stations
are static with respect to a given planning problem instance.

This variant is usually denoted as \textit{Transport numeric} or \textit{transport-numeric}.

\subsection{Transport Temporal}\label{transport-temporal}

The temporal Transport domain is usually denoted as \textit{Transport temporal} or, confusingly,
also \textit{transport-numeric}. A major difference with respect to the numeric variant is
the addition of time. All actions now have a duration (\verb+pick-up+ and \verb+drop+ both have a
duration of 1, \verb+refuel+ has a duration of 10, and the duration of \verb+drive+ is
equal to the length of the road we are driving along). Furthermore, packages can now have any integral size.

The addition of time poses numerous technical complications when formalizing this variant
-- its PDDL (Section~\ref{pddl}) formulation significantly differs from the two previous ones, but only in technical details.
One important technicality is that a vehicle cannot pick up or drop packages concurrently -- it always handles packages one at a time. Also, vehicles cannot do other actions during driving to another location (they are essentially placed ``off the graph'' for the duration of driving).

The overall goal remains largely the same (deliver packages to their destinations), but we no longer optimize the total cost. Instead, we now minimize the total duration of a plan,
defined as the maximum time where an action is still taking place.
In practice, this translates to minimizing maximum end time over all actions.



















\section{Formalizing the Transport domain}

We will now translate the informal description of the Transport domain from the previous section to the formal representations we defined in Section~\ref{classical-planning}. We will not formulate all the domain variants in all representations as
they are very much alike and not needed for the comprehension of the following chapters.

\subsection{Transport's classical representation}\label{transport-classical-representation}

We are now able to show the sequential Transport domain in one of the representations
previously defined, namely,
the classical representation (Figure~\ref{code:classical-strips}).
Note that this representations does not contain the notion of a \textit{total cost}
of a plan that we will optimize for later.
The predicates used are:

\begin{itemize}
\item \verb+at(o, l)+, the package or vehicle \verb+o+ is at the
location \verb+l+;
\item \verb+capacity(v, s)+, the vehicle \verb+v+ currently has \verb+s+ free space -- \verb+s+ is a variable for space literals, a set of literals denoting the amount of space (essentially interpretable as a finite set of integers);
\item \verb+capacity-predecessor(s1, s2)+, the space literal represented by \verb+s1+
is directly smaller than the literal represented by \verb+s2+;
\item \verb+in(p, v)+, the package \verb+p+ is in the vehicle \verb+v+; and
\item \verb+road(l1, l2)+, the location \verb+l1+ is directly adjacent to the location
\verb+l2+ by a road.
\end{itemize}

\begin{figure}[tbp]
\begin{code}
drive(v, l1, l2)
  ;; vehicle v moves from location l1 to an adjacent location l2
  precond: at(v, l1), road(l1, l2)
  effects: not at(v, l1), at(v, l2)

pick-up(v, l, p, s1, s2)
  ;; vehicle v picks up package p at location l,
  ;; decreasing its capacity from s2 to s1
  precond: at(v, l), at(p, l), capacity-predecessor(s1, s2),
           capacity(v, s2)
  effects: not at(p, l), in(p, v), capacity(v, s1),
           not capacity(v, s2)
  
drop(v, l, p, s1, s2)
  ;; vehicle v drops package p at location l,
  ;; increasing its capacity from s1 to s2
  precond: at(v, l), in(p, v), capacity-predecessor(s1, s2),
           capacity(v, s1)
  effects: not in(p, v), at(p, l), capacity(v, s2),
           not capacity(v, s1)
\end{code}
\caption{Classical formulation of \texttt{transport-strips}.}
\label{code:classical-strips}
\end{figure}

The numeric variant  adds the \verb+refuel+ operator, changes the \verb+drive+
operator, and adds a new fuel-related predicate \verb+has-petrol-station(l)+, that is true when the given location \verb+l+ has
a petrol station.
To model fuel, we need the addition of a few functions, namely:

\begin{itemize}
\item \verb+fuel-demand(l1, l2)+, the amount of fuel needed to drive
from location \verb+l1+ to location \verb+l2+;
\item \verb+fuel-left(v)+, the amount of fuel left in
the vehicle \verb+v+; and
\item \verb+fuel-max(v)+, the maximum amount of fuel
the vehicle \verb+v+ can contain, i.e. its fuel tank capacity.
\end{itemize}

It is obvious that we could substitute the functions for relations
and a finite amount of literals for any given problem instance of
the domain in this representation,
so that it adheres to the definition of a classical formulation.
For example, we could add literals representing a finite set of
natural numbers and predicate that represents
\verb+successor+ defined as $\texttt{successor}(a, b) \equiv a + 1 = b$.

We also abuse the notation with \verb+decrease+ and \verb+assign+;
the left parameter's value is to be decreased by the right
parameter's value or the left parameter's value is to be overridden
by the right parameter's value, respectively.

See Figure~\ref{code:classical-numeric} for the exact differences
in the representation after adding fuel.

\begin{figure}[tbp]
\begin{code}
drive(v, l1, l2)
  ;; vehicle v moves from location l1 to an adjacent location l2
  precond: at(v, l1), road(l1, l2), fuel-left(v) >= fuel-demand(l1, l2)
  effects: not at(v, l1), at(v, l2),
           decrease(fuel-left(v),  fuel-demand(l1, l2))
  
refuel(v, l)
  ;; vehicle v is refueled to the maximum at location l
  precond: at(v, l), has-petrol-station(l)
  effects: assign(fuel-left(v), fuel-max(v))
\end{code}
\caption{Classical formulation of \texttt{transport-numeric}'s differences compared to \texttt{transport-strips}.}
\label{code:classical-numeric}
\end{figure}

\subsection{Transport's state-variable representation}

We are now also able to show the sequential Transport domain
in the state-variable representation (Figure~\ref{code:statevar-strips}).
Some predicates (\verb+at+, \verb+capacity+ and \verb+in+) have been transformed
into state-variable functions with largely the same semantics as in
Section~\ref{transport-classical-representation}. Again, we leave out
the \textit{total cost} notion.

\begin{figure}[tbp]
\begin{code}
drive(v, l1, l2)
  ;; vehicle v moves from location l1 to an adjacent location l2
  precond: at(v) = l1, road(l1, l2)
  effects: at(v) <- l2

pick-up(v, l, p, s1, s2)
  ;; vehicle v picks up package p at location l,
  ;; decreasing its capacity from s2 to s1
  precond: at(v) = l, at(p) = l, s1 + 1 = s2, s2 > 0, capacity(v) = s2
  effects: at(p) <- nil, in(p) <- v, capacity(v) <- s1
  
drop(v, l, p, s1, s2)
  ;; vehicle v drops package p at location l,
  ;; increasing its capacity from s1 to s2
  precond: at(v) = l, in(p) = v, s1 = s2 - 1, capacity(v) = s1
  effects: in(p) <- nil, at(p) <- l, capacity(v) <- s2
\end{code}
\caption{State-variable formulation of \texttt{transport-strips}.}
\label{code:statevar-strips}
\end{figure}

The numeric variant again adds the \verb+refuel+ operator along with
a few fuel-related state-variable functions and predicates, and changes 
the \verb+drive+ operator (Figure~\ref{code:statevar-numeric}).

\begin{figure}[tb]
\begin{code}
drive(v, l1, l2)
  ;; vehicle v moves from location l1 to an adjacent location l2
  precond: at(v) = l1, road(l1, l2), fuel-left(v) >= fuel-demand(l1,l2)
  effects: at(v) <- l2, fuel-left(v) <-  fuel-demand(l1, l2)
  
refuel(v, l)
  ;; vehicle v is refueled to the maximum at location l
  precond: at(v) = l, has-petrol-station(l)
  effects: fuel-left(v) <- fuel-max(v)
\end{code}
\caption{State-variable formulation of \texttt{transport-numeric}'s differences
compared to \texttt{transport-strips}.}
\label{code:statevar-numeric}
\end{figure}

\TODO{Temporal Transport's state-variable representation + code}

\subsection{PDDL formulation of Transport}

All formulations of the Transport domain use the basic PDDL (Section~\ref{pddl}) version 2.1,
with the requirement \verb+typing+, which adds the notion of types for individual
literals. We will call these literals \textit{action objects}.

The STRIPS variant additionally needs \verb+action-costs+, a requirement adding
integer costs to indiviudal planning operators. These costs may be constant
(like the ones for \verb+pick-up+, \verb+drop+ or \verb+refuel+),
or they may be dependent on the parameters of the instantiated operator (like
the cost of \verb+drive+).
The numeric variant
requires \verb+numeric-fluents+ (introduces native PDDL support for numbers) and
\verb+goal-utilities+ (custom optimization functions and optional goal predicates).
The temporal domain is similar in requirements to the numeric one, except for
substituting \verb+goal-utilities+ for \verb+durative-actions+ (introduces time
and the duration of actions).

One problem with the diversity of these domain formulations is that rarely does
a single planner support the union of all these requirements.
We show the capabilities of individual studied planners
later on, in Table~\ref{tab:plannner-requirements-comparison}.
For reference, we show the PDDL representation of the sequential variant of
the Transport domain in Figure~\ref{code:pddl-strips}.

\begin{figure}[tbp]
\begin{code}
(define (domain transport)
  (:requirements :typing :action-costs)
  (:types
        location target locatable - object
        vehicle package - locatable
        capacity-number - object)
  (:predicates 
     (road ?l1 ?l2 - location)
     (at ?x - locatable ?v - location)
     (in ?x - package ?v - vehicle)
     (capacity ?v - vehicle ?s1 - capacity-number)
     (capacity-predecessor ?s1 ?s2 - capacity-number))
  (:functions
     (road-length ?l1 ?l2 - location) - number
     (total-cost) - number)     
  (:action drive
    :parameters (?v - vehicle ?l1 ?l2 - location)
    :precondition (and (at ?v ?l1) (road ?l1 ?l2))
    :effect (and (not (at ?v ?l1)) (at ?v ?l2)
        (increase (total-cost) (road-length ?l1 ?l2))))        
 (:action pick-up
    :parameters (?v - vehicle ?l - location ?p - package
                 ?s1 ?s2 - capacity-number)
    :precondition (and (at ?v ?l) (at ?p ?l)
        (capacity-predecessor ?s1 ?s2) (capacity ?v ?s2))
    :effect (and (not (at ?p ?l)) (in ?p ?v) (capacity ?v ?s1)
        (not (capacity ?v ?s2)) (increase (total-cost) 1)))
  (:action drop
    :parameters (?v - vehicle ?l - location ?p - package
                 ?s1 ?s2 - capacity-number)
    :precondition (and (at ?v ?l) (in ?p ?v)
        (capacity-predecessor ?s1 ?s2) (capacity ?v ?s1))
    :effect (and (not (in ?p ?v)) (at ?p ?l) (capacity ?v ?s2)
        (not (capacity ?v ?s1)) (increase (total-cost) 1))))
\end{code}
\caption{PDDL formulation of \texttt{transport-strips}.}
\label{code:pddl-strips}
\end{figure}



\TODO{Temporal formulation.}














\section{Related problems}

Most of the research done on transportation-related problems and their automation focuses
on a famous combinatorial optimization problem, the \textit{Travelling Salesman Problem} (TSP), on which an
exhaustive amount of research has been done \citep{Applegate1998, Applegate2011}.
Its precise origins are unknown, but the problem has been on the minds of researchers at least since the end of the 19$^\textrm{th}$ century. The TSP is defined by \citet{Applegate2011} as follows:

\begin{quote}
Given a set of cities along with the cost of travel between each pair of them, the \textit{traveling salesman problem}, or \textit{TSP} for short, is to find the cheapest way of visiting all the cities and returning to the starting point. The ``way of visiting all the cities'' is simply the order in which the cities are visited; the ordering is called a \textit{tour} or \textit{circuit} through the citites.
\end{quote}

However, the problem we aim to study is more similar to a different optimization problem based on the TSP.

\subsection{The Vehicle Routing Problem}

The \textit{Vehicle Routing Problem} (VRP) was first formulated as the \textit{Truck Dispatching Problem} by \citet{Dantzig1959}, modeling a fleet of vehicles delivering gasoline to service stations. They described VRP as a generalization of the TSP with multiple vehicles, but it could equivalently be stated that the TSP is a specialization of the VRP
with a single vehicle. The precise formulation of the Truck Dispatching Problem in \citep[Section~2]{Dantzig1959} represents a model with a fleet of identical vehicles departing from single depot. According to \citet[Section~3]{Braekers2016}, this defines what we would call \textit{Capacitated VRP} (CVRP) today.

Many different VRP variants have emerged since. \citet{Eksioglu2009} and \citet{Braekers2016} both
review and classify hundreds of papers related to the VRP, with many more left out.
Most of these works tend to study the CVRP problem with minor modifications, hence creating
a broad landscape of problems and a platform to build on for the future.
According to the data in \citet[Table~4]{Braekers2016}, there has been a recent uptick
in popularity for models relatively similar to Transport -- specially, VRPs with
backhauls (returning items from customers to depots),
multiple depots (multiple starting points for vehicles), and with allowed split deliveries (multiple
vehicles can serve a single customer).
The literature review on multiple depot VRP (MDVRP) in \citet{Montoya-Torres2015}
suggests a big rise in popularity for MDVRP in the recent past,
which provides further proof of relevance for studying the Transport domain.

Traditional solutions for the VRP include exact approaches like branch and bound
exploring the whole feasible search space,
classical heuristics which limit the search space, and also metaheuristics (general heuristics for devising specific heuristics), like genetic algorithms, constraint satisfaction
programming, local search, tabu search, and many more.

\comment{
\subsection{VRP Formulation}\citep{ResearchGroup2013}

The VRP is a combinatorial problem whose ground set is the edges of a graph ${G(V,E)}$. The notation used for this problem is as follows:

\begin{itemize}
\item ${V = \left\lbrace v_{0}, v_{1}, \ldots, v_{n} \right\rbrace}$ is a vertex set, where:
\begin{itemize}
\item Consider a depot to be located at ${v_0}$.
\item Let ${V' = V \backslash \left\lbrace v_{0} \right\rbrace}$ be used as the set of ${n}$ cities.
\end{itemize}
\item ${A = \left\lbrace(v_{i},v_{j}) | v_{i},v_{j} \in V; i \neq j \right\rbrace}$ is an arc set.
\item ${C}$ is a matrix of non-negative costs or distances ${c_{ij}}$ between customers ${v_{i}}$ and ${v_{j}}$.
\item ${d}$ is a vector of the customer demands.
\item ${R_{i}}$ is the route for vehicle ${i}$.
\item ${m}$ is the number of vehicles (all identical). One route is assigned to each vehicle.
\end{itemize}

When $c_{ij} = c_{ji}$ for all $(v_{i}, v_{j}) \in A$ the problem is said to be symmetric and it is then common to replace ${A}$ with the edge set $E = \lbrace (v_{i},v_{j}) | v_{i},v_{j} \in V; i < j \rbrace$.

With each vertex ${v_{i}}$ in ${V'}$ is associated a quantity ${q_{i}}$ of some goods to be delivered by a vehicle. The VRP thus consists of determining a set of ${m}$ vehicle routes of minimal total cost, starting and ending at a depot, such that every vertex in ${V'}$ is visited exactly once by one vehicle.

For easy computation, it can be defined ${b(V) = \left\lceil \sum_{v_{i} \in V} d_{i}) / C \right\rceil}$, an obvious lower bound on the number of trucks needed to service the customers in set ${V}$.

We will consider a service time $\delta_{i}$ (time needed to unload all goods), required by a vehicle to unload the quantity ${q_{i}}$ at ${v_{i}}$. It is required that the total duration of any vehicle route (travel plus service times) may not surpass a given bound ${D}$, so, in this context the cost ${c_{ij}}$ is taken to be the travel time between the cities. The VRP defined above is NP-hard [Lenstra \& Rinnooy Kan 1981].

A feasible solution is composed of:

\begin{itemize}
\item a partition ${R_{1}, \ldots, R_{m}}$ of ${V}$;
\item a permutation ${\sigma_{i}}$ of ${R_{i} \bigcup {0}}$ specifying the order of the customers on route ${i}$.
\end{itemize}


The cost of a given route (${R_{i} = \left\lbrace v_{0}, v_{1}, \ldots, v_{m+1} \right\rbrace}$), where ${v_{i} \in V}$ and ${v_{0} = v_{m+1} = 0}$ (0 denotes the depot), is given by ${C(R_{i}) = \sum_{i=0}^{m} c_{i,i+1} + \sum_{i=1}^{m} \delta_{i}}$.

A route ${R_{i}}$ is feasible if the vehicle stop exactly once in each customer and the total duration of the route does not exceed a prespecified bound ${D}$: ${C(R_{i}) \leq D}$.

Finally, the cost of the problem solution ${S}$ is: ${F_{VRP} = \sum_{i=1}^{m} F(R_{i})}$.
}

\subsection{Comparison of Transport and VRP}

In \citet{ResearchGroup2013}, a website was created, which serves as a comprehensive resource on the history of VRP,
definitons of its various flavors, an overview of the popular solution methods and state-of-the-art results. According to the taxonomy proposed, we could characterize the Transport domain
as a Multiple Depot Split Delivery Capacitated VRP with Satellite Facilities. Multiple Depot
means that vehicles can start driving from multiple locations, split delivery
means a single customer can be served by multiple vehicles, capacitated VRP adds maximum
capacities to vehicles, and satellite facilities means that vehicles can pick items up
while on a route. This does not characterize the Transport domain in every detail,
but is fairly accurate.

According to another VRP taxonomy and study of papers, presented in \citet{Eksioglu2009} and adapted similarly in \citet{Braekers2016}, no research has been done on a VRP variant with a similar subset of features in any single study, to the best of our knowledge.
Usually, the studied problems are more constrained than Transport -- for example, they make additional assumptions about the places where vehicles start or end. Also, VRP in general
makes cooperation of vehicles hard to model, whereas in Transport this is one of the fundamental elements.

\comment{Transport could be characterized as \textit{2.1.1, 2.2.1, 2.4.1, 2.5.1, 2.8.1, 3.1.1, 3.2.2, 3.3.3, 3.4.2, 3.5.2, 3.7.1, 3.8.1, 3.9.3, 3.10.1, 3.11.1, 4.1.1, 4.2.1, 4.3.2, 4.4.1, 5.1.2.}}

The fundamental difference between Transport and the VRP is that Transport has a notion of single packages, or items, compared to the VRP, the transported goods are usually regarded as measurable, rather than countable (for example gasoline or milk vs. letters or parcels). This makes a difference not only in the
interpretation, but also during problem solving -- \textit{customers} in VRP usually request
a quantity of the delivered item, not specific item instances, like packages being ``requested''
by their target locations in Transport. \TODO{reread and expand}

\subsection{Constraint Satisfaction Problems}\label{csp}

Constraint satistfaction techniques are a popular means of solving problems in combinatorial optimization. \citet[Section~8.1]{Ghallab2004} give an informal definition of a \textit{Constraint Satisfaction
Problem} (CSP):

\begin{quote}
Given (1) a set of variables and their respective domains, and (2) a set of constraints on the compatible values that the variables may take, the problem is to find a value for each variable within its domain such that these values meet all the constraints.
\end{quote}

\TODO{define state space + size}

\TODO{Expand and quote an authoritative CSP source}

\subsection{Past solutions and approaches to Transport}

\TODO{\ldots see \citep{Skopek2017}}












\section{TransportEditor -- A Transportation Planning System}

In the next few sections, we will analyze various Transport domain variants and problem
instances. To aid us and others in studying transportation planning,
we have developed \textit{TransportEditor} --- a system for creating and visualizing transportation problems and plans.

Specifically, TransportEditor aims to be a problem editor and plan visualizer for the Transport domain (and its variants). It is an intuitive and cross-platform graphical desktop application (Figure~\ref{fig:transporteditor-screenshot})
written in Java.

It allows the user to create a planning session, where they
select a Transport domain variant, load a problem instance from PDDL (Section~\ref{pddl}) or create a new one from scratch.
The road network of the problem is automatically layed out and visualized for the user as a graph with locations as nodes and roads as edges.
Users can then tweak the layout, make changes to vehicle and package properties
and export the problem or domain back into PDDL.

They can also select an external planner
referencing its executable file, or select one of the built-in planners and try to solve
the loaded problem using the selected planner. Internal and external plan validators, like VAL \citep{Howey2003}, can also be selected to verify plans are correct.
Once plans are loaded and verified, it will let the user see a list of actions
in the plan, or plot a Gantt chart (useful for observing concurrent actions in temporal domain variants).

The best feature of TransportEditor is the option of tracing plans. We can select
any action, specify an exact timepoint or just step through the actions in order and
the road network on the left will display the current state of the problem, as if
all actions before the current point were applied to the start state.
It is possible to do all of this, and more, without ever leaving the TransportEditor user interface.

TransportEditor will help researchers working on this domain fine-tune their planners; they can visualize the various corner cases their planner fails to handle, step through the generated plan and find the points where their approach fails.
A secondary motivation is to be able to test approaches for creating plans for the domain.
For screenshots of typical TransportEditor usage, see the attached \nameref{transport-editor-screenshots}.

\begin{figure}[tbp]
\begin{center}
\includegraphics[width=0.9\textwidth]{../img/transporteditor_temporal}
\end{center}
\caption{Screenshot of a user tracing actions of a plan for a smaller temporal problem in TransportEditor.}
\label{fig:transporteditor-screenshot}
\end{figure}

The basic user workflow of TransportEditor consists of the following steps:
\begin{itemize}
\item Selecting which formulation of the Transport domain they want to work with or create their own variant;
\item Loading the PDDL or creating their own problem of the given domain. TransportEditor then visualizes the given graph as good as it can;
\item Iterating among the following options:
\begin{itemize}
\item Loading a planner executable and letting TransportEditor run the planner on the loaded problem instance for a given time (the user can cancel any time),
then loading the resulting plan;
\item Possibly loading a pre-generated plan;
\item Stepping through the individual plan actions and letting TransportEditor visualize them.
The user can step forward and backward in the plan and inspect each action result in great detail;
\item Editing the graph: adding/removing/editing the location or properties of vehicles, packages, roads, locations and possibly petrol stations;
\item Saving the currently generated plan;
\item Saving the problem;
\item Saving the domain (exporting to a PDDL file).
\end{itemize}
\item Saving and closing the currently loaded problem. Exit the application or go back to the first step.
\end{itemize}

TransportEditor is a part of this thesis and you can find it on the attachment CD (see the attached \nameref{cd-contents} for more information). Both the \nameref{transporteditor-user-manual},
the \nameref{transporteditor-developer-manual}, and the \nameref{transporteditor-developer-javadoc} are attached to this thesis in a digital format, offerring guidance when
using the program and providing an in-depth description.














\section{Transport domain analysis}

In this section, we will delve more deeply into the Transport domain and try to analyze its features.
We will describe the problem instances that have been used in the IPC and discuss potential
heuristics and approaches to creating plans for these problems.

\TODO{mention Logistics, Depots, and DriverLog}

\subsection{Does domain knowledge make Transport easy to solve?}

When domain-independent planners solve a sequential Transport problem,
they face a harder task than our planners that have domain knowledge ahead of time.
Deciding whether a plan of a given length exists is, in the case of Transport,
an NEXPTIME-complete task \citep{Ghallab2004}[Section~3.4].
That does not mean domain knowledge makes Transport easy. We will now show
that even the sequential variant of Transport is NP-hard.

\begin{thm}
The problem of finding an optimal plan for an undirected connected graph in the sequential
Transport domain is NP-hard. \TODO{Formulate better and revise proof}
\end{thm}
\begin{proof}
It is not evident if the problem is in NP: if we get a plan, there is no straigh-forward
way of verifying whetherit is optimal.

We will now show that we can reduce an NP-complete problem to our problem in polynomial time,
hence proving that all NP-complete problems are reducible to our problem,
and therefore, our problem is NP-hard.

As proven by \citet{Karp1972}, the problem of existance of a Hamilton circuit (HC) in a (directed or undirected) graph is NP-complete. We will show that we are able to transform the HC problem into a sequential Transport problem.

Given an undirected graph $G$, the solution to HC is a cycle through all the nodes of $G$,
without visiting any single node twice.
We can use the same graph to model a Transport problem instance.
The problem will contain only one vehicle of capacity $n-1$,
where $n = |G|$, the size of number of nodes in the graph.

We will co-locate $n-1$ packages with the vehicle at any predetermined graph vertex $l \in G$.
One package $p'$ will be located elsewhere, at $l' \in G,\, l \neq l'$.
Each package positioned at $l$ will have a different target than the other packages at $l$
and none of the targets will be $l$. The package at $l'$ will have the original node $l$
as its target. We will set all road lengths to $1$. 

An optimal plan for the designed translation has a total cost of at least $3n$.
Any plan for this problem has to have at least $n$ \verb+drive+ actions, because
there is a package to be delivered to every node, and the graph has $n$ nodes.
Because it has to move $n$ packages, at least $n$ \verb+pick-up+ and $n$ \verb+drop+
actions are needed. The costs of all actions are 1.
We conjecture that an HC exists if and only if an optimal and valid plan visits each vertex only once.

First, we prove the forward implication. Assume an HC exists and the optimal plan visits at least one node twice. We can now construct a plan with a lower total cost than the optimal plan: first, pick up all the $n-1$ co-located packages, then drive along the HC. At each
visited node, drop the package that has this node as its destination. If we are at $l'$,
pick up the package $p'$. The plan is trivially valid, as it delivers all packages
and the vehicle never over-reaches its capacity. Also, its total cost is $3n$
(the length of the HC is $n$, which implies $n$ drive actions) and for every of the $n$ packages, we do exactly one \verb+pick-up+ and exactly one \verb+drop+. Hence, the plan
is optimal and visits each vertex only once.

Now, assume an HC does not exist. If the found optimal plan only visits each node once,
we can look at the source locations of all \verb+drive+ actions and the target
location of the last \verb+drive+ action. They constitute a path through the graph on which a node never repeats and the path starts and finishes at the same node.
Hence, we have constructed a HC.
\end{proof}

\subsection{Domain features}

\TODO{insights, degenerate cases, etc.}



















\section{Datasets}

We have acquired several datasets from previous runs of the IPC which we will use to test our planners.
Table~\ref{tab:ipc-datasets} provides an overview of the distinct datasets, their associated IPC competition, track at the competition and the formulation used (descriptions of the tracks in hyperlinks).

\begin{table}[tb]
\begin{tabular}{c||ccc}
\textbf{Dataset} & \textbf{Competition} & \textbf{IPC Track} & \textbf{Formulation} \\ 
\hline
\hline
netben-opt-6 & IPC-6 & \href{http://icaps-conference.org/ipc2008/deterministic/NetBenefitOptimization.html}{Net-benefit: optimal} & Numeric \\ 
seq-opt-6 & IPC-6 & \href{http://icaps-conference.org/ipc2008/deterministic/SequentialOptimization.html}{Sequential: optimal} & STRIPS \\ 
seq-sat-6 & IPC-6 & \href{http://icaps-conference.org/ipc2008/deterministic/SequentialSatisficing.html}{Sequential: satisficing} & STRIPS \\ 
tempo-sat-6 & IPC-6 & \href{http://icaps-conference.org/ipc2008/deterministic/TemporalSatisficing.html}{Temporal: satisficing} & Temporal \\ 
\hline
seq-agl-8 & IPC-8 & \href{https://helios.hud.ac.uk/scommv/IPC-14/seqagi.html}{Sequential: agile} & STRIPS \\ 
seq-mco-8 & IPC-8 & \href{https://helios.hud.ac.uk/scommv/IPC-14/seqmulti.html}{Sequential: multi-core} & STRIPS \\ 
seq-opt-8 & IPC-8 & \href{https://helios.hud.ac.uk/scommv/IPC-14/seqopt.html}{Sequential: optimal} & STRIPS \\ 
seq-sat-8 & IPC-8 & \href{https://helios.hud.ac.uk/scommv/IPC-14/seqsat.html}{Sequential: satisficing} & STRIPS \\ 
\end{tabular}
\caption{Transport datasets from the IPC}
\label{tab:ipc-datasets}
\end{table}

Short descriptions of the various tracks and subtracks can be found in the rule pages of IPC-6\footnote{\url{https://helios.hud.ac.uk/scommv/IPC-14/rules.html}}
and the rule pages of IPC-8\footnote{\url{http://icaps-conference.org/ipc2008/deterministic/CompetitionRules.html}}.
Unfortunately, we weren't able to acquire the datasets for IPC-7, as the Subversion repository\footnote{\url{http://www.plg.inf.uc3m.es/ipc2011-deterministic/Domains.html}} that promises to contain them is unavailable.

\subsection{Problem instances}

\TODO{specific problems we will be using}

\subsection{Problem features}

\TODO{features and peculiarities of the problem instances}
















\section{Formulating Transport as a CSP}

\TODO{intro}

\subsection{Na{\"{i}}ve formulation}

We will now formulate a sequential Transport (Section~\ref{transport-strips}) problem as a CSP (Section~\ref{csp}) using the na{\"{i}}ve encoding provided in \citet[Section~8.3]{Ghallab2004}.
However, using that strategy, our problems ``blow up'' in size -- as is expected due
to the different complexities of planning versus solving CSPs \citep[Section~8.3.2]{Ghallab2004}. To visualize the difference in our case, we have constructed a state space estimation table (Table~\ref{tab:csp-trivial}) for conversions of two sample sequential Transport problems.

\begin{table}[tb]
\begin{center}
\begin{tabular}{l||rr}
\textbf{Features / estimates} & \textbf{p01} & \textbf{p20} \\ 
\hline 
\hline 
\textbf{Best known plan length} & 6 & 351 \\ 
\textbf{Vehicles} & 2 & 4 \\ 
\textbf{Vehicle variables} & 14 & 1 408 \\ 
\textbf{Packages} & 2 & 20 \\ 
\textbf{Package variables} & 14 & 7 040 \\ 
\textbf{Locations} & 5 & 60 \\ 
\textbf{Roads} & 12 & 256 \\
\textbf{Max capacity} & 4 & 4 \\ 
\hline
\textbf{Ground Drive actions} & 168 & 360 448 \\ 
\textbf{Ground PickUp actions} & 140 & 1 689 600 \\ 
\textbf{Ground Drop actions} & 140 & 1 689 600 \\ 
\hline 
\textbf{Planning variables total} & 48 & 10 207 \\ 
\textbf{Grounded actions total} & 448 & 1 189 838 848 \\ 
\textbf{Search Space Estimate} & $\approx 1.1 \cdot 10^{52}$ & $\approx 1.4 \cdot 10^{27 952}$ \\ % https://www.wolframalpha.com/input/?i=(245120%5E351)+*+4%5E1408+*+60%5E1408+*+1468%5E7040
\end{tabular}
\end{center}
\caption{CSP Search space approximations for the \textit{p01} and \textit{p20} problems from the \textit{seq-sat} track of IPC 2008, using the general and domain-independent encoding from \citet[Section~8.3]{Ghallab2004}.}
\label{tab:csp-trivial}
\end{table}

The first section of the table (rows 1--7) contains problem-specific constants.
The two calcualted values in that section, \textit{Vehicle variables} and \textit{Package variables} are the amount of variables generated for the respective
object by grounding it for every intermediate plan state (before and after applying an action). Therefore, the value is equal to the number of vehicles/packages of the problem
multiplied by the set plan length $+ 1$ (each state corresponds to the state before applying an action + the last state).

In the second section (rows 8--10), we estimate the number of ground actions
Step 1 from \citet[Section~8.3.1]{Ghallab2004} will generate.
We calculate the number of \pickup{} and \drop{} actions the CSP encoding will generate
as $$(\mt{length(plan)} + 1) \cdot \mt{\#vehicles} \cdot \mt{\#locations} \cdot \mt{\#packages},$$
effectively counting all ground planning operators of the problem. Similarly,
the number of \drive{} actions is calculated as
$$(\mt{length(plan)} + 1) \cdot \mt{\#vehicles} \cdot \mt{\#roads},$$
which is more efficient than the na{\"{i}}ve way of
counting all
$$(\mt{length(plan)} + 1) \cdot \mt{\#vehicles} \cdot \mt{\#locations}^2$$
actions.

As we can see from the third section of the table, the number of variables
(planning variables and ground actions) is not extremely high --
the problem is that the variables have very large domains,
which makes the CSP problem exponentially larger \citep[Section~8.3.2]{Ghallab2004}.
We calculated the \textit{Search Space Size Estimate} (SSE) as
\begin{align*}
\mt{SSE} =\; &\mt{\#ground\_actions}^{l-1} & \textit{\footnotesize select ground actions for the plan}\\
&\cdot \mt{\#capacities}^{l \cdot \mt{\#vehicles}} & \textit{\footnotesize select capacities for vehicle variables}\\
&\cdot \mt{\#locations}^{l \cdot \mt{\#vehicles}} & \textit{\footnotesize select locations for vehicle variables}\\
&\cdot (\mt{\#locations} + \mt{\#vehicles})^{l \cdot \mt{\#pkg}}, & \textit{\footnotesize select locations/vehicles for package variables}
\end{align*}
where we set $l := \mt{length(plan) + 1}$.
For comparison to the SSEs in the last table row, 
the estimated number of atoms in the universe is generally estimated to be about $4 \cdot 10^{80}$.

\subsection{Domain-dependent formulation}\label{csp-custom-repr}

\TODO{domain-dep formulation, note the shadow variable overhead}


\begin{table}[tb]
\begin{center}
\begin{tabular}{l||rr}
\textbf{Features / estimates} & \textbf{p01} & \textbf{p20} \\ 
\hline 
\hline 
\textbf{Best known plan length} & 6 & 351 \\ 
\textbf{Vehicles} & 2 & 4 \\ 
\textbf{Vehicle shadow vars} & 14 & 1 408 \\
\textbf{Packages} & 2 & 20 \\ 
\textbf{Package shadow vars} & 14 & 7 040 \\
\textbf{Locations} & 5 & 60 \\ 
\textbf{Roads} & 12 & 256 \\
\textbf{Max capacity} & 4 & 4 \\ 
\hline
\textbf{Ground Drive actions} & 24 & 1024 \\ 
\textbf{Ground PickUp actions} & 20 & 4800 \\ 
\textbf{Ground Drop actions} & 20 & 4800 \\ 
\hline 
\textbf{Planning variables total} & 48 & 10 207 \\ 
\textbf{Grounded actions in step} & 64 & 10 624 \\ 
\textbf{Action type orderings} & 2 187 & $\approx 8.8 \cdot 10^{167}$ \\ 
\textbf{Search Space Estimate} & $\approx 1.5 \cdot 10^{14}$ & $\approx 2.0 \cdot 10^{637}$ \\
\end{tabular}
\end{center}
\caption{CSP Search space approximations for the \textit{p01} and \textit{p20} problems from the \textit{seq-sat} track of IPC 2008, using a custom domain-dependent CSP encoding for Transport sequential.}
\label{tab:csp-custom}
\end{table}

Using the domain-dependent encoding specified previously, we are now able to construct
a search space estimate table for the same Transport problems (Table~\ref{tab:csp-custom}). While the table rows look similar, sections 2 and 3 are calculated
differently. The ground action counts in section 2 are not multiplied by $\mt{length(plan)} + 1$
as done previously, because we only represent them once, not at every plan state.
The total number of grounded actions is the same, but they are not explicitly represented as variables. The Search Space size Estimate is therefore calculated differently:
\begin{align*}
\mt{SSE} =\; &3^{\mt{length(plan)} + 1} & \textit{\footnotesize select the action type of each action}\\
&\cdot \mt{\#ground\_actions}^{l-1}. & \textit{\footnotesize select the specific ground action}
\end{align*}
For comparison to the na{\"{i}}ve encoding SSEs which going from the p01 problem to the p20 grow by a logarithmic factor of approximately $538$,
whereas the domain-dependent ones only grow by approximately $46$,
which is a huge improvement.

Given the search space reduction, we will attempt to use this representation
for constructing a CSP-based planner in Section~\ref{csp-approach}.
